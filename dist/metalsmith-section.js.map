{"version":3,"sources":["../index.js"],"names":[],"mappings":"AAAA,IAAM,QAAQ,QAAQ,OAAR,EAAiB,oBAAjB,CAAd;;AACA,IAAM,aAAa,QAAQ,YAAR,CAAnB;AACA;AAEA;;;AACA,OAAO,OAAP,GAAiB,MAAjB;AAEA;;;;;;;;;;;AAUA,SAAS,MAAT,CAAgB,IAAhB,EACA;AAEI,SAAO,QAAQ,EAAf;AACA,OAAK,OAAL,GAAe,KAAK,OAAL,IAAgB,CAAC,WAAD,CAA/B;AACA,OAAK,MAAL,GAAc,KAAK,MAAL,IAAe,YAA7B;AACA,OAAK,kBAAL,GAA0B,KAAK,kBAAL,IAA2B,IAArD;AACA,OAAK,WAAL,GAAmB,KAAK,WAAL,IAAoB,UAAvC;AAEA,QAAM,sBAAN,EAA8B,KAAK,SAAL,CAAe,IAAf,CAA9B;AAEA,SAAO,SAAS,KAAT,CAAe,KAAf,EAAsB,UAAtB,EAAkC,IAAlC,EACP;AAEI,iBAAa,IAAb;AAEA,WAAO,IAAP,CAAY,KAAZ,EAAmB,OAAnB,CAA2B,UAAC,IAAD,EAC3B;AAEI,UAAI,WAAW,IAAX,EAAiB,KAAK,OAAtB,EAA+B,MAAnC,EACA;AAEI,YAAM,OAAO,MAAM,IAAN,CAAb;AAEA,cAAM,qBAAN,EAA6B,IAA7B,EAAmC,KAAK,MAAxC;AAEA,YAAM,KAAK,IAAI,MAAJ,eAAkB,KAAK,MAAvB,GAAgC,GAAhC,CAAX;AAEA,YAAM,aAAa,KAAK,QAAL,CAAc,QAAd,EAAnB;AAEA,YAAM,UAAU,WAAW,KAAX,CAAiB,EAAjB,CAAhB;AAEA,YAAI,QAAQ,MAAR,IAAkB,CAAtB,EAAyB;AAEzB,aAAK,KAAK,WAAV,IAAyB,EAAzB;;AAEA,YAAI,KAAK,kBAAT,EACA;AACI,gBAAM,oBAAN,EAA2B,QAAQ,CAAR,CAA3B;AACA,gBAAM,IAAN,EAAY,QAAZ,GAAuB,OAAO,IAAP,CAAY,QAAQ,CAAR,CAAZ,CAAvB;AACH;;AAED,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,CAAJ,IAAS,QAAQ,MAAjC,EAAyC,KAAK,CAA9C,EACA;AACI,cAAM,SAAS,QAAQ,CAAR,CAAf;AACA,cAAM,OAAO,OAAO,KAAP,CAAa,cAAb,EAA6B,CAA7B,EAAgC,IAAhC,EAAb;AACA,cAAM,UAAU,OAAO,OAAP,CAAe,cAAf,EAA8B,EAA9B,EAAkC,IAAlC,EAAhB,CAHJ,CAKI;;AACA,cAAI,KAAK,KAAK,WAAV,EAAuB,IAAvB,CAAJ,EACA;AACI,gBAAM,eAAe,KAAK,KAAK,WAAV,EAAuB,IAAvB,CAArB,CADJ,CAGI;;AACA,gBAAI,OAAO,YAAP,KAAwB,QAA5B,EACA;AACI,mBAAK,KAAK,WAAV,EAAuB,IAAvB,IAA+B,CAC3B,YAD2B,EAE3B,OAF2B,CAA/B;AAIH,aAND,CAQA;AARA,iBASK,IAAI,MAAM,OAAN,CAAc,YAAd,CAAJ,EACL;AACI,qBAAK,KAAK,WAAV,EAAuB,IAAvB,EAA6B,IAA7B,CAAkC,OAAlC;AACH;AAEJ,WAnBD,CAqBA;AArBA,eAuBA;AACI,mBAAK,KAAK,WAAV,EAAuB,IAAvB,IAA+B,OAA/B;AACH;;AAED,gBAAM,IAAN,EAAY,OAAZ;AACH;AACJ;AACJ,KA/DD;AAgEH,GArED;AAsEH","file":"metalsmith-section.js","sourcesContent":["const debug = require(\"debug\")(\"metalsmith:section\");\nconst multimatch = require(\"multimatch\");\n/* eslint-disable id-length */\n\n// Expose `plugin`.\nmodule.exports = plugin;\n\n/**\n * Metalsmith plugin to section html into named chunks\n *\n * @param {Object} opts - Options to pass to the plugin.\n * @param {string} opts.pattern - The pattern used to match to the file paths.\n * @param {string} opts.prefix - The token to split the html into sections by.\n * @param {boolean} opts.removeFromContents - Whether or not to remove sections from the content metaData.\n * @param {string} opts.metaDataKey - What property to store result in the metadata.\n * @return {function}  The plugin function\n */\nfunction plugin(opts)\n{\n\n    opts = opts || {};\n    opts.pattern = opts.pattern || [\"**/*.html\"];\n    opts.prefix = opts.prefix || \"section:::\";\n    opts.removeFromContents = opts.removeFromContents || true;\n    opts.metaDataKey = opts.metaDataKey || \"sections\"\n\n    debug(\"myplugin options: %s\", JSON.stringify(opts));\n\n    return function parse(files, metalsmith, done)\n    {\n\n        setImmediate(done);\n\n        Object.keys(files).forEach((file) =>\n        {\n\n            if (multimatch(file, opts.pattern).length)\n            {\n\n                const data = files[file];\n\n                debug(\"converting file: %s\", file, opts.prefix);\n\n                const re = new RegExp(`<.*>${opts.prefix}`,\"g\");\n\n                const dataString = data.contents.toString()\n\n                const strings = dataString.split(re);\n\n                if (strings.length <= 1) return\n\n                data[opts.metaDataKey] = {}\n\n                if (opts.removeFromContents)\n                {\n                    debug(\"remaining content:\",strings[0])\n                    files[file].contents = Buffer.from(strings[0])\n                }\n\n                for (let i = 1; i + 1 <= strings.length; i += 1)\n                {\n                    const string = strings[i]\n                    const name = string.match(/^(.*?)<\\/.*>/)[1].trim()\n                    const section = string.replace(/^(.*?)<\\/.*>/,\"\").trim()\n\n                    // if we already have something for that key\n                    if (data[opts.metaDataKey][name])\n                    {\n                        const currentValue = data[opts.metaDataKey][name]\n\n                        // if its a string, stick it in an array\n                        if (typeof currentValue === \"string\")\n                        {\n                            data[opts.metaDataKey][name] = [\n                                currentValue,\n                                section\n                            ]\n                        }\n\n                        // if its an array append the new value\n                        else if (Array.isArray(currentValue))\n                        {\n                            data[opts.metaDataKey][name].push(section)\n                        }\n\n                    }\n\n                    // if this is new\n                    else\n                    {\n                        data[opts.metaDataKey][name] = section;\n                    }\n\n                    debug(name, section)\n                }\n            }\n        });\n    };\n}\n"]}